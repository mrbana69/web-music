<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1c1c1e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ReApple Music</title>
    <link rel="icon" href="data:,">
    <link rel="manifest" href="manifest.json">
    <!-- dash.js - Official DASH library for progressive chunk streaming -->
    <script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
    <style>
        :root {
            --bg-color: #000000;
            --bg-secondary: #1c1c1e;
            --bg-tertiary: #2c2c2e;
            --text-primary: #ffffff;
            --text-secondary: #8e8e93;
            --accent: #fa2d48; /* Apple Music Pink/Red */
            --accent-dim: rgba(250, 45, 72, 0.15);
            --divider: #38383a;
            --blur-bg: rgba(30, 30, 30, 0.85);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --safe-area-bottom: env(safe-area-inset-bottom);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #000000 0%, #1a1a1e 100%);
            background-attachment: fixed;
            color: var(--text-primary);
            overflow-x: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- Icons --- */
        .icon {
            width: 24px;
            height: 24px;
            fill: currentColor;
            display: block;
        }
        .icon-sm { width: 18px; height: 18px; }
        .icon-lg { width: 32px; height: 32px; }
        .icon-xl { width: 44px; height: 44px; }

        /* --- Layout --- */
        .main-container {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 180px; /* Space for player + tab bar */
            scroll-behavior: smooth;
        }

        .container {
            padding: 0 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* --- Header --- */
        header {
            padding: 40px 20px 10px;
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            z-index: 10;
        }

        h1 {
            font-size: 34px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .header-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        /* --- Search --- */
        .search-wrapper {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 10px 12px;
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            margin-top: 15px;
        }

        .search-input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 17px;
            width: 100%;
            outline: none;
        }
        
        .search-wrapper > svg { margin-right: 10px; }

        .search-input::placeholder { color: var(--text-secondary); }

        /* --- Grids & Lists --- */
        .section-title {
            font-size: 22px;
            font-weight: 700;
            margin: 24px 0 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-primary);
        }

        .btn-text {
            color: var(--accent);
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-text:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px 16px;
        }

        .card {
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .card:active { transform: scale(0.95); }
        .card:hover { transform: scale(1.02); }

        .artwork {
            width: 100%;
            height: 0;
            padding-bottom: 100%; /* Fallback per aspect-ratio */
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 8px;
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
        }

        .artwork img {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .card-title {
            font-size: 15px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
        }

        .card-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- List View (Playlist) --- */
        .list-item {
            display: flex;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 12px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .list-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .list-item > .list-artwork { margin-right: 16px; }
        .list-item > .list-info { margin-right: 16px; }
        
        .list-item:last-child { border-bottom: none; }

        .list-artwork {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--glass-bg), rgba(255, 255, 255, 0.08));
            overflow: hidden;
            border: 1px solid var(--glass-border);
        }
        
        .list-artwork img { width: 100%; height: 100%; object-fit: cover; }

        .list-info { flex: 1; overflow: hidden; }

        /* --- Tab Bar --- */
        .tab-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 85px; /* taller for safe area */
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 1px solid var(--glass-border);
            display: flex;
            justify-content: space-around;
            padding-top: 10px;
            padding-bottom: calc(10px + var(--safe-area-bottom));
            z-index: 100;
        }

        .tab-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 10px;
            width: 60px;
            transition: color 0.2s ease;
        }

        .tab-btn > svg { margin-bottom: 4px; }

        .tab-btn.active { color: var(--accent); }

        /* --- Mini Player --- */
        .mini-player {
            position: fixed;
            bottom: 110px; /* Above tab bar */
            left: 10px;
            right: 10px;
            height: 64px;
            background: rgba(35, 35, 35, 0.6);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            z-index: 90;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);

            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
            transform: translateY(150%);
        }

        .mini-player.visible { transform: translateY(0); }

        .mini-player > .mini-art { margin-right: 12px; }
        .mini-player > .mini-info { margin-right: 12px; }

        .mini-art {
            width: 44px;
            height: 44px;
            border-radius: 6px;
            background: #333;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .mini-art img { width: 100%; height: 100%; object-fit: cover; }

        .mini-info { flex: 1; overflow: hidden; display: flex; flex-direction: column; justify-content: center; }
        .mini-text { 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            font-size: 15px; 
            font-weight: 500;
            width: 100%;
        }
        .mini-artist { color: var(--text-secondary); font-weight: 400; font-size: 12px; width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .mini-controls { display: flex; align-items: center; padding-right: 4px; }
        .mini-controls > .control-btn + .control-btn { margin-left: 16px; }

        .control-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: background 0.2s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        /* --- Full Screen Player Modal --- */
        .full-player {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 20, 0.95) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            z-index: 200;
            display: flex;
            flex-direction: column;
            padding: 60px 30px 40px;
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.32, 0.72, 0, 1);
            visibility: hidden;
        }

        .full-player.active { transform: translateY(0); visibility: visible; }

        .full-art-container {
            width: 100%;
            height: 0;
            padding-bottom: 100%; /* Fallback per aspect-ratio */
            margin: 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transform: scale(0.9);
            transition: transform 0.5s ease;
        }

        .full-player.active .full-art-container { transform: scale(1); }

        .full-art-container img { 
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%; object-fit: cover; 
        }

        .full-info { margin-bottom: 30px; }
        .full-title { font-size: 24px; font-weight: 700; margin-bottom: 6px; }
        .full-artist { font-size: 20px; color: var(--text-accent); opacity: 0.8; }

        .full-info > div > :not(:last-child) { margin-right: 15px; }

        .progress-container { margin-bottom: 40px; }
        .progress-bar-bg {
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }
        .progress-fill {
            height: 100%;
            background: #fff; /* White progress bar like Apple */
            border-radius: 2px;
            width: 0%;
        }
        .time-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 12px;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
        }

        .main-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
        }

        .vol-container {
            display: flex;
            align-items: center;
        }
        .vol-container > :not(:last-child) { margin-right: 15px; }

        .vol-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        .vol-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* Loading Spinner */
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Utility */
        .hidden { display: none !important; }
        
        .active-tab-content { display: block; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Badge for Hi-Res */
        .badge {
            font-size: 10px;
            padding: 2px 6px;
            border: 1px solid var(--accent);
            color: var(--accent);
            border-radius: 4px;
            margin-left: 8px;
            font-weight: 700;
        }

        /* --- Player Views (Lyrics/Queue) --- */
        .player-footer {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-top: 20px;
        }

        .lyrics-view, .queue-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px 30px;
            overflow-y: auto;
            z-index: 10;
            display: none;
            text-align: left;
            mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 90%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 90%, transparent 100%);
        }

        .lyrics-view.active, .queue-view.active { display: block; }

        .lyrics-line {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 24px;
            color: rgba(255,255,255,0.5);
            transition: all 0.3s ease;
            cursor: pointer;
            line-height: 1.4;
        }

        .lyrics-line.active {
            color: #fff;
            transform: scale(1.05);
            transform-origin: left;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        /* --- Syllable/Word Sync Styles --- */
        .lyric-word {
            display: inline-block;
            border-radius: 4px;
            transition: transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.2s ease, color 0.2s ease;
            opacity: 0.7;
        }
        .lyrics-line.active .lyric-word { opacity: 0.6; }
        .lyrics-line.active .lyric-word.active {
            opacity: 1; color: #fff; transform: scale(1.15); text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .translate-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(255,255,255,0.1);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
        }

        .like-btn {
            background: none;
            border: none;
            cursor: pointer;
        }

        .delete-btn {
            padding: 8px;
            color: var(--text-secondary);
            background: none;
            border: none;
            z-index: 5;
        }
        .delete-btn:hover { color: var(--accent); }

        #importOverlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 300;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        #importLog {
            width: 100%;
            max-width: 400px;
            height: 300px;
            overflow-y: auto;
            background: #1c1c1e;
            border-radius: 12px;
            padding: 15px;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
            color: #ccc;
        }

        /* --- Tablet / Desktop Responsive Tweaks --- */
        .full-player-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .player-visual-column {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            margin-bottom: 30px; /* Sostituisce gap */
        }

        .player-controls-column {
            width: 100%;
        }

        @media (min-width: 768px) {
            .full-player-content {
                flex-direction: row;
                align-items: center;
                justify-content: center;
                max-width: 1000px;
                margin: 0 auto;
            }
            
            .full-player-content > .player-visual-column { margin-right: 60px; margin-bottom: 0; }

            .player-visual-column {
                flex: 1;
                max-width: 500px;
                height: auto;
                padding-bottom: 0;
                aspect-ratio: 1 / 1;
            }

            .player-controls-column {
                flex: 1;
                max-width: 400px;
            }

            .lyrics-view, .queue-view { border-radius: 12px; }
        }

        /* --- Animations & Transitions --- */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .animate-in {
            animation: fadeInUp 0.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            opacity: 0;
        }

        /* Interactive Elements Scale & Feedback */
        .control-btn, .btn-text, .tab-btn, .card, .list-item, .mini-player {
            transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s ease, background-color 0.2s;
        }
        .control-btn:active, .btn-text:active, .tab-btn:active {
            transform: scale(0.92);
        }
        .card:active, .list-item:active {
            transform: scale(0.96);
            background-color: rgba(255,255,255,0.05);
        }

        /* Full Player Staggered Animation */
        .full-player .full-info,
        .full-player .progress-container,
        .full-player .main-controls,
        .full-player .vol-container,
        .full-player .player-footer {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .full-player.active .full-info { opacity: 1; transform: translateY(0); transition-delay: 0.1s; }
        .full-player.active .progress-container { opacity: 1; transform: translateY(0); transition-delay: 0.15s; }
        .full-player.active .main-controls { opacity: 1; transform: translateY(0); transition-delay: 0.2s; }
        .full-player.active .vol-container { opacity: 1; transform: translateY(0); transition-delay: 0.25s; }
        .full-player.active .player-footer { opacity: 1; transform: translateY(0); transition-delay: 0.3s; }

        /* --- Small Screen Adjustments (iPhone SE, Huawei P9 Lite, etc.) --- */
        @media (max-width: 400px) {
            .full-player {
                padding: 40px 15px 20px;
            }

            .full-art-container {
                width: 90%;
                height: 0;
                padding-bottom: 90%;
            }

            .full-info {
                margin-bottom: 20px;
            }

            .full-title {
                font-size: 20px;
            }

            .full-artist {
                font-size: 16px;
            }

            .progress-container {
                margin-bottom: 30px;
            }

            .main-controls {
                margin-bottom: 30px;
            }

            .player-visual-column {
                margin-bottom: 20px;
            }

            .mini-player {
                bottom: 95px;
                left: 5px;
                right: 5px;
                height: 56px;
                padding: 0 8px;
            }

            .mini-art {
                width: 40px;
                height: 40px;
            }

            .mini-info {
                margin-right: 8px;
            }

            .mini-text {
                font-size: 14px;
            }

            .mini-artist {
                font-size: 11px;
            }

            .mini-controls > .control-btn + .control-btn {
                margin-left: 12px;
            }

            .tab-bar {
                height: 75px;
                padding-bottom: calc(5px + var(--safe-area-bottom));
            }

            .tab-btn {
                width: 50px;
            }

            .tab-btn > svg {
                margin-bottom: 2px;
            }

            .tab-btn > span {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>

    <div id="tab-home" class="main-container active-tab-content">
        <header>
            <div class="header-actions">
                <h1>Listen Now</h1>
                <button class="btn-text" onclick="document.getElementById('csvInput').click()">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                </button>
            </div>
        </header>
        <div class="container">
            <h2 class="section-title">Top Picks</h2>
            <div class="grid" id="recommendations">
                </div>
        </div>
    </div>

    <div id="tab-search" class="main-container hidden">
        <header>
            <h1>Search</h1>
            <div class="search-wrapper">
                <svg class="icon icon-sm" style="color:var(--text-secondary)" viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
                <input type="text" class="search-input" id="searchInput" placeholder="Artists, Songs, Lyrics">
            </div>
        </header>
        <div class="container" id="searchResults"></div>
    </div>

    <div id="tab-collection" class="main-container hidden">
        <header>
            <div class="header-actions">
                <button class="btn-text" onclick="closeCollection()">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
                </button>
                <h1 id="collectionTitle">Playlist</h1>
                <div style="width:24px"></div> <!-- Spacer -->
            </div>
        </header>
        <div class="container" id="collectionList"></div>
    </div>

    <div id="tab-playlist-page" class="main-container hidden">
        <header>
            <div class="header-actions">
                <button class="btn-text" onclick="closePlaylistPage()">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
                </button>
                <div style="flex:1;"></div>
            </div>
        </header>
        <div class="container">
            <div style="text-align:center; padding:40px 0;">
                <img id="playlistPageCover" src="" alt="Playlist Cover" style="width:200px; height:200px; border-radius:12px; object-fit:cover; margin-bottom:20px; box-shadow: 0 8px 30px rgba(0,0,0,0.3);">
                <h1 id="playlistPageTitle" style="margin-bottom:10px;">Playlist Name</h1>
                <p id="playlistPageCount" style="color:var(--text-secondary); margin-bottom:30px;">0 songs</p>
                <button id="playlistPlayBtn" class="btn-primary" style="padding:12px 30px; background:var(--accent); color:white; border:none; border-radius:25px; font-weight:600; cursor:pointer; font-size:16px;">
                    <svg class="icon" viewBox="0 0 24 24" style="display:inline; margin-right:8px;"><path d="M8 5v14l11-7z" fill="currentColor"/></svg>
                    Play
                </button>
            </div>
            <h2 class="section-title" style="margin-top:30px;">Songs</h2>
            <div id="playlistSongsList"></div>
        </div>
    </div>

    <div id="tab-library" class="main-container hidden">
        <header>
            <h1>Library</h1>
        </header>
        <div class="container">
            <div class="list-item" onclick="openLikedSongs()">
                <div class="list-artwork"><div style="background:linear-gradient(135deg, #fa2d48, #ff9f0a); width:100%; height:100%; display:flex; align-items:center; justify-content:center;"><svg class="icon" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg></div></div>
                <div class="list-info"><div class="card-title">Liked Songs</div><div class="card-subtitle">Auto-generated</div></div>
            </div>

            <div class="section-title">
                <span>Playlists</span>
                <div style="display:flex;">
                    <button class="btn-text" onclick="document.getElementById('csvInput').click()">Import</button>
                    <div style="width:15px"></div>
                    <button class="btn-text" onclick="createPlaylist()">New</button>
                </div>
            </div>
            <input type="file" id="csvInput" hidden accept=".csv" onchange="handleCSVImport(this)">
            <div id="playlistsList"></div>

            <div class="section-title" style="margin-top: 40px;">
                <span>Settings</span>
            </div>
            <div class="list-item" onclick="clearCacheAndUpdate()">
                <div class="list-artwork" style="display:flex; align-items:center; justify-content:center;"><svg class="icon" viewBox="0 0 24 24"><path fill="currentColor" d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg></div>
                <div class="list-info">
                    <div class="card-title">Update App - Fix</div>
                    <div class="card-subtitle">Force reload the latest version uploaded</div>
                </div>
            </div>
        </div>
    </div>

    <div class="mini-player" id="miniPlayer" onclick="openFullPlayer()">
        <div class="mini-art">
            <img src="" id="miniArt" alt="">
        </div>
        <div class="mini-info">
            <span class="mini-text" id="miniTitle">Not Playing</span>
            <span class="mini-artist" id="miniArtist"></span>
        </div>
        <div class="mini-controls" onclick="event.stopPropagation()">
            <button class="control-btn" id="miniPlayBtn" onclick="togglePlay()">
                <svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            </button>
            <button class="control-btn" onclick="nextTrack()">
                <svg class="icon" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
            </button>
        </div>
    </div>

    <div class="tab-bar">
        <button class="tab-btn active" onclick="switchTab('home')">
            <svg class="icon" viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
            <span>Listen Now</span>
        </button>
        <button class="tab-btn" onclick="switchTab('search')">
            <svg class="icon" viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
            <span>Search</span>
        </button>
        <button class="tab-btn" onclick="switchTab('library')">
            <svg class="icon" viewBox="0 0 24 24"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H8V4h12v12z"/></svg>
            <span>Library</span>
        </button>
    </div>

    <div class="full-player" id="fullPlayer">
        
        <div class="full-player-content">
            <div class="player-visual-column">
                <div class="full-art-container" id="artContainer">
                    <img src="" id="fullArt" alt="">
                </div>

                <!-- Lyrics View -->
                <div class="lyrics-view" id="lyricsView">
                    <button class="translate-btn hidden" id="translateBtn" onclick="toggleTranslation()">Translate to Italian</button>
                    <div id="lyricsContent" style="padding-top: 50px; padding-bottom: 50px;"></div>
                </div>

                <!-- Queue View -->
                <div class="queue-view" id="queueView">
                    <h2 class="section-title" style="margin-top:0">Playing Next</h2>
                    <div id="queueList"></div>
                </div>
            </div>

            <div class="player-controls-column">
                <div class="full-info">
                    <div class="full-title" id="fullTitle">Song Title</div>
                    <div class="full-artist" id="fullArtist">Artist Name</div>
                </div>

                <div class="progress-container">
                    <div class="progress-bar-bg" onclick="seek(event)">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="time-labels">
                        <span id="currentTime">0:00</span>
                        <span id="totalTime">-:--</span>
                    </div>
                </div>

                <div class="main-controls">
                    <button class="control-btn" style="opacity: 0.6" id="shuffleBtn" onclick="toggleShuffle()">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg>
                    </button>
                    <button class="control-btn" onclick="prevTrack()">
                        <svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
                    </button>
                    <button class="control-btn" id="fullPlayBtn" onclick="togglePlay()" style="transform: scale(1.5);">
                        <svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    </button>
                    <button class="control-btn" onclick="nextTrack()">
                        <svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
                    </button>
                    <button class="control-btn" style="opacity: 0.6" id="repeatBtn" onclick="toggleRepeat()">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>
                    </button>
                </div>

                <div class="vol-container">
                    <svg class="icon-sm" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                    <input type="range" class="vol-slider" min="0" max="1" step="0.01" value="1" oninput="setVolume(this.value)">
                    <svg class="icon-sm" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                </div>

                <div class="player-footer">
                    <button class="control-btn" onclick="closeFullPlayer()">
                        <svg class="icon" viewBox="0 0 24 24" fill="currentColor"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                    </button>
                    <button class="control-btn" onclick="togglePlayerView('lyrics')">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M15 4v2h3v12h-3v2h5V4h-5zm-9 2H4v12h2V6zm11 4h-8v2h8v-2zm0 4h-8v2h8v-2z"/></svg>
                    </button>
                    <button class="control-btn" onclick="togglePlayerView('queue')">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>
                    </button>
                    <button class="control-btn" id="likeBtn" onclick="toggleLike()">
                        <svg class="icon" style="color:var(--text-secondary)" viewBox="0 0 24 24"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"/></svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <audio id="nativeAudio"></audio>

    <script>
        // --- 1. Universal Player using dash.js (Official DASH Library) ---
        // dash.js is the official DASH library that handles progressive chunk streaming
        // Perfect for APIs serving DASH manifests - downloads chunks, not full file
        class UniversalPlayer {
            constructor() {
                this.videoElement = document.createElement('video');
                this.videoElement.style.display = 'none';
                document.body.appendChild(this.videoElement);
                this.dashPlayer = null;
                this.isPlaying = false;
                this.isInit = false;
            }

            async loadFromDASH(xmlUrl) {
                try {
                    // Check if dash.js is available
                    if (typeof dashjs === 'undefined') {
                        console.warn("dash.js not loaded, falling back to native audio");
                        return false;
                    }

                    // Stop any existing player
                    if (this.dashPlayer) {
                        this.dashPlayer.destroy();
                        this.dashPlayer = null;
                    }

                    // Initialize dash.js player with optimal settings
                    this.dashPlayer = dashjs.MediaPlayer().create();
                    
                    // Configure for low latency and better handling
                    this.dashPlayer.updateSettings({
                        streaming: {
                            buffer: {
                                stableBufferTime: 2,
                                bufferTimeAtTopQuality: 10
                            },
                            gaps: {
                                jumpGaps: true
                            },
                            lowLatencyEnabled: false
                        }
                    });

                    // Initialize the video element with the DASH manifest
                    this.dashPlayer.initialize(this.videoElement, xmlUrl, false);

                    return new Promise((resolve) => {
                        const onStreamInitialized = () => {
                            this.isInit = true;
                            this.dashPlayer.off(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitialized);
                            resolve(true);
                        };

                        const onError = (event) => {
                            console.error("dash.js error:", event);
                            this.dashPlayer.off(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitialized);
                            this.dashPlayer.off(dashjs.MediaPlayer.events.ERROR, onError);
                            resolve(false);
                        };

                        this.dashPlayer.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, onStreamInitialized);
                        this.dashPlayer.on(dashjs.MediaPlayer.events.ERROR, onError);
                    });
                } catch (e) {
                    console.error("Universal player load failed", e);
                    return false;
                }
            }

            play() { 
                if (this.videoElement) {
                    this.videoElement.play(); 
                    this.isPlaying = true;
                }
            }
            pause() { 
                if (this.videoElement) {
                    this.videoElement.pause(); 
                    this.isPlaying = false;
                }
            }
            setVolume(v) { 
                if (this.videoElement) {
                    this.videoElement.volume = v; 
                }
            }
            seek(time) { 
                if (this.videoElement) {
                    this.videoElement.currentTime = time; 
                }
            }
            
            reset() {
                if (this.dashPlayer) {
                    try {
                        this.dashPlayer.destroy();
                    } catch (e) {}
                    this.dashPlayer = null;
                }
                if (this.videoElement) {
                    this.videoElement.pause();
                    this.videoElement.removeAttribute('src');
                    this.videoElement.currentTime = 0;
                }
                this.isInit = false;
            }
            
            get audioElement() {
                // Return video element as audio source (dash.js uses video element for audio streams)
                return this.videoElement;
            }
        }

        // --- 1b. Custom DASH / MSE Player (The "Progressive Download" Logic) ---
        class DashPlayer {
            constructor() {
                this.mediaSource = null;
                this.sourceBuffer = null;
                this.audioElement = document.createElement('audio'); // MSE attaches here
                this.queue = [];
                this.isInit = false;
                this.isPlaying = false;
                this.loadId = 0;
            }

            attachTo(elementId) {
                // Not strictly necessary as we play audio in background, but useful for events
                // For this implementation, we use an internal audio element for MSE
            }

            async loadFromXML(xmlString) {
                if (this.mediaSource) {
                    this.reset();
                }

                // Parse XML
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlString, "text/xml");
                
                // Extract Info
                const representation = doc.querySelector('Representation');
                const template = doc.querySelector('SegmentTemplate');
                const timelineNodes = doc.querySelectorAll('SegmentTimeline S');
                const mimeType = doc.querySelector('AdaptationSet').getAttribute('mimeType'); // audio/mp4
                const codecs = representation.getAttribute('codecs'); // flac
                const timescale = parseInt(template.getAttribute('timescale'));
                const initUrl = template.getAttribute('initialization');
                const mediaUrlTemplate = template.getAttribute('media');
                const startNumber = parseInt(template.getAttribute('startNumber') || "1");

                // Generate Segment List
                let segments = [];
                let currentNumber = startNumber;
                let currentTime = 0;

                timelineNodes.forEach(node => {
                    const d = parseInt(node.getAttribute('d'));
                    const r = parseInt(node.getAttribute('r') || "0"); // Repeat count
                    
                    // Add the first segment of this node
                    segments.push({ number: currentNumber, duration: d, time: currentTime });
                    currentNumber++;
                    currentTime += d;

                    // Add repeats
                    for(let i = 0; i < r; i++) {
                        segments.push({ number: currentNumber, duration: d, time: currentTime });
                        currentNumber++;
                        currentTime += d;
                    }
                });

                // Initialize MSE
                this.mediaSource = new MediaSource();
                this.audioElement.src = URL.createObjectURL(this.mediaSource);
                
                return new Promise((resolve, reject) => {
                    this.mediaSource.addEventListener('sourceopen', async () => {
                        try {
                            // "audio/mp4; codecs='flac'" might need specific browser support. 
                            // If fails, fallback logic would go here.
                            const codecString = `${mimeType}; codecs="${codecs}"`;
                            this.sourceBuffer = this.mediaSource.addSourceBuffer(codecString);
                            
                            // 1. Fetch Init Segment
                            const initData = await this.fetchSegment(initUrl);
                            this.sourceBuffer.appendBuffer(initData);

                            this.sourceBuffer.addEventListener('updateend', () => {
                                if (!this.isInit) {
                                    this.isInit = true;
                                    this.loadSegmentsProgressively(segments, mediaUrlTemplate);
                                    resolve();
                                }
                            });
                        } catch(e) {
                            console.error("MSE Error", e);
                            reject(e);
                        }
                    }, { once: true });
                });
            }

            async fetchSegment(url) {
                const response = await fetch(url);
                return await response.arrayBuffer();
            }

            async loadSegmentsProgressively(segments, urlTemplate) {
                const currentId = this.loadId;
                // This simulates the "Progressive Download"
                for (const seg of segments) {
                    if (this.loadId !== currentId) break;
                    if (!this.mediaSource || this.mediaSource.readyState === 'closed') break;

                    const url = urlTemplate.replace('$Number$', seg.number);
                    
                    try {
                        const data = await this.fetchSegment(url);
                        
                        if (this.loadId !== currentId) break;

                        let appended = false;
                        while (!appended) {
                            if (this.loadId !== currentId) break;
                            
                            while(this.sourceBuffer && this.sourceBuffer.updating) {
                                await new Promise(r => setTimeout(r, 50));
                            }
                            if (this.loadId !== currentId) break;

                            try {
                                this.sourceBuffer.appendBuffer(data);
                                appended = true;
                            } catch (err) {
                                if (err.name === 'QuotaExceededError') {
                                    const currentTime = this.audioElement.currentTime;
                                    if (currentTime > 10) {
                                        if (!this.sourceBuffer.updating) {
                                            this.sourceBuffer.remove(0, currentTime - 10);
                                        }
                                    } else {
                                        await new Promise(r => setTimeout(r, 1000));
                                    }
                                } else {
                                    throw err;
                                }
                            }
                        }
                    } catch (e) {
                        console.error("Segment load failed", e);
                        if (e.name === 'QuotaExceededError') break;
                    }
                }
                
                while(this.sourceBuffer && this.sourceBuffer.updating) {
                    await new Promise(r => setTimeout(r, 50));
                }

                if (this.loadId === currentId && this.mediaSource && this.mediaSource.readyState === 'open') {
                    this.mediaSource.endOfStream();
                }
            }

            play() { this.audioElement.play(); this.isPlaying = true; }
            pause() { this.audioElement.pause(); this.isPlaying = false; }
            setVolume(v) { this.audioElement.volume = v; }
            seek(time) { this.audioElement.currentTime = time; }
            
            reset() {
                this.loadId++;
                if (this.audioElement) {
                    this.audioElement.pause();
                    if (this.mediaSource && this.sourceBuffer) {
                        try {
                            if (this.sourceBuffer.updating) this.sourceBuffer.abort();
                            if (this.mediaSource.readyState === 'open') {
                                this.mediaSource.removeSourceBuffer(this.sourceBuffer);
                            }
                        } catch (e) {}
                    }
                    this.audioElement.removeAttribute('src');
                    this.audioElement.load();
                }
                this.isInit = false;
                this.mediaSource = null;
                this.sourceBuffer = null;
            }
        }

        // --- 2. App State & Logic ---
        const API_URL = 'https://api.monochrome.tf'; // Using one for stability
        const universalPlayer = new UniversalPlayer();
        const dashPlayer = new DashPlayer();
        const nativeAudio = document.getElementById('nativeAudio');

        // Auto-advance logic (Handles Shuffle/Mix when song ends)
        universalPlayer.audioElement.addEventListener('ended', () => nextTrack());
        dashPlayer.audioElement.addEventListener('ended', () => nextTrack());
        nativeAudio.addEventListener('ended', () => nextTrack());
        
        let state = {
            queue: [],
            currentIndex: 0,
            isPlaying: false,
            isHiRes: false,
            volume: 1,
            shuffle: false,
            repeat: false,
            lyrics: null,
            syncedLyrics: [],
            showTranslation: false,
            likedSongs: JSON.parse(localStorage.getItem('likedSongs') || '[]'),
            playlists: JSON.parse(localStorage.getItem('playlists') || '[]'),
            currentPlaylistIndex: -1, // Track current playlist being played
            mixLoaded: false // Track if mix has been loaded for current song
        };

        // --- 3. UI Interactions ---

        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            ['home', 'search', 'library', 'collection'].forEach(t => {
                document.getElementById('tab-' + t).classList.add('hidden');
                document.getElementById('tab-' + t).classList.remove('active-tab-content');
            });

            const active = document.getElementById('tab-' + tabName);
            active.classList.remove('hidden');
            active.classList.add('active-tab-content');

            if (tabName === 'home') loadRecommendations();
            if (tabName === 'library') renderPlaylists();
        }

        function openFullPlayer() {
            document.getElementById('fullPlayer').classList.add('active');
        }

        function closeFullPlayer() {
            document.getElementById('fullPlayer').classList.remove('active');
        }

        // Swipe down to close full player
        let touchStartY = 0;
        let touchEndY = 0;

        const fullPlayer = document.getElementById('fullPlayer');
        fullPlayer.addEventListener('touchstart', (e) => {
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        fullPlayer.addEventListener('touchend', (e) => {
            touchEndY = e.changedTouches[0].screenY;
            if (touchEndY - touchStartY > 100) { // Swipe down threshold
                closeFullPlayer();
            }
        }, { passive: true });

        // --- 4. Audio Control Wrapper ---
        // Handles routing between UniversalPlayer (all platforms), DashPlayer (legacy), and Native Audio (fallback)

        async function clearCacheAndUpdate() {
            if ('serviceWorker' in navigator) {
                try {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    if (registrations.length) {
                        for (const registration of registrations) {
                            await registration.unregister();
                        }
                    }

                    const keys = await caches.keys();
                    await Promise.all(keys.map(key => caches.delete(key)));

                    alert('Cache cleared successfully! The application will now reload.');
                    window.location.reload(true);

                } catch (error) {
                    console.error('Failed to clear cache:', error);
                    alert('Error clearing cache. Please try clearing your browser cache manually.');
                }
            } else {
                alert('Service workers are not supported in this browser.');
            }
        }

        // Load mix for a given track (used as fallback/auto-queue loader)
        async function loadMix(track, fromSearch = false) {
            try {
                if (state.mixLoaded) return;

                const infoRes = await fetch(`${API_URL}/info/?id=${track.id}`);
                const infoData = await infoRes.json();

                if (infoData.data && infoData.data.mixes && infoData.data.mixes.TRACK_MIX) {
                    const mixId = infoData.data.mixes.TRACK_MIX;
                    const mixRes = await fetch(`${API_URL}/mix?id=${mixId}`);
                    const mixData = await mixRes.json();

                    const items = mixData.items || (mixData.data && mixData.data.items);
                    if (items) {
                        const newTracks = items.filter(t => t.id !== track.id).map(t => {
                            if (t.artists && !t.artist) {
                                t.artist = t.artists[0];
                            }
                            return t;
                        });
                        if (newTracks.length > 0) {
                            state.queue.push(...newTracks);
                            updateQueueUI();
                            state.mixLoaded = true;
                        }
                    }
                } else if (fromSearch) {
                    // Fallback to search-based mix: add next items from search results
                    try {
                        const query = encodeURIComponent(track.title + ' ' + (track.artist?.name || ''));
                        const searchRes = await fetch(`${API_URL}/search/?s=${query}`);
                        const searchData = await searchRes.json();

                        if (searchData.data && searchData.data.items) {
                            const currentIndex = searchData.data.items.findIndex(t => t.id === track.id);
                            if (currentIndex !== -1 && currentIndex < searchData.data.items.length - 1) {
                                const nextSongs = searchData.data.items.slice(currentIndex + 1, currentIndex + 6);
                                if (nextSongs.length > 0) {
                                    state.queue.push(...nextSongs);
                                    updateQueueUI();
                                    state.mixLoaded = true;
                                }
                            }
                        }
                    } catch (e) {
                        console.error("Search-based mix failed", e);
                    }
                }
            } catch (e) {
                console.error("Mix load failed", e);
            }
        }

        async function playTrack(track, fromQueue = false, fromSearch = false, playlistIndex = -1) {
            addToHistory(track);
            state.mixLoaded = false;
            
            if (!fromQueue) {
                state.queue = [track];
                state.currentIndex = 0;
                state.currentPlaylistIndex = playlistIndex;
                if (typeof loadMix === 'function') loadMix(track, fromSearch).catch(e => console.error(e));
            }

            const currentTrack = state.queue[state.currentIndex];
            updatePlayerUI(currentTrack);
            fetchLyrics(currentTrack);
            updateMediaSession(currentTrack);
            document.getElementById('miniPlayer').classList.add('visible');

            nativeAudio.pause();
            universalPlayer.reset();
            dashPlayer.reset();

            try {
                // Step 1: Fetch the initial JSON manifest from the API
                const manifestRes = await fetch(`${API_URL}/track/?id=${currentTrack.id}&quality=LOSSLESS`);
                if (!manifestRes.ok) throw new Error(`Manifest fetch failed with status: ${manifestRes.status}`);
                const manifestData = await manifestRes.json();

                // Step 2: Decode the Base64 manifest string to get the second manifest
                if (!manifestData.data || !manifestData.data.manifest) {
                    throw new Error("Initial manifest format is incorrect.");
                }
                const streamManifestStr = atob(manifestData.data.manifest);
                const streamManifest = JSON.parse(streamManifestStr);

                // Step 3: Extract the final playable URL from the second manifest
                if (!streamManifest.urls || streamManifest.urls.length === 0) {
                    throw new Error("No stream URL found in the final manifest.");
                }
                const streamUrl = streamManifest.urls[0];

                // Step 4: Set the source and play the audio
                nativeAudio.src = streamUrl;
                await nativeAudio.play();

                state.isPlaying = true;
                updatePlayIcons();

            } catch (e) {
                console.error("Playback failed with error:", e);
                alert(`Playback failed: ${e.message}. Please try again.`);
                state.isPlaying = false;
                updatePlayIcons();
            }
        }

        function togglePlay() {
            state.isPlaying = !state.isPlaying;
            
            if (universalPlayer.isInit) {
                state.isPlaying ? universalPlayer.play() : universalPlayer.pause();
            } else if (state.isHiRes && dashPlayer.isInit) {
                state.isPlaying ? dashPlayer.play() : dashPlayer.pause();
            } else {
                state.isPlaying ? nativeAudio.play() : nativeAudio.pause();
            }
            updatePlayIcons();
        }

        function updateMediaSession(track) {
            if ('mediaSession' in navigator) {
                const artUrl = track.album?.cover 
                    ? `https://resources.tidal.com/images/${track.album.cover.replace(/-/g, '/')}/640x640.jpg`
                    : 'https://cdn-icons-png.flaticon.com/512/4430/4430494.png';

                navigator.mediaSession.metadata = new MediaMetadata({
                    title: track.title,
                    artist: track.artist?.name || "Unknown Artist",
                    album: track.album?.title || "Unknown Album",
                    artwork: [
                        { src: artUrl, sizes: '512x512', type: 'image/jpeg' }
                    ]
                });

                navigator.mediaSession.setActionHandler('play', togglePlay);
                navigator.mediaSession.setActionHandler('pause', togglePlay);
                navigator.mediaSession.setActionHandler('previoustrack', prevTrack);
                navigator.mediaSession.setActionHandler('nexttrack', nextTrack);
            }
        }

        async function nextTrack() {
            if (state.queue.length === 0) return;
            
            if (state.currentIndex >= state.queue.length - 1) {
                await loadMix(state.queue[state.currentIndex]);
            }

            let nextIndex = state.currentIndex + 1;
            if (nextIndex >= state.queue.length) nextIndex = 0;
            
            playTrackFromQueue(nextIndex);
        }

        function prevTrack() {
            if (state.queue.length === 0) return;
            let player;
            
            if (universalPlayer.isInit) {
                player = universalPlayer.audioElement;
            } else if (state.isHiRes && dashPlayer.isInit) {
                player = dashPlayer.audioElement;
            } else {
                player = nativeAudio;
            }
            
            if (player.currentTime > 3) {
                player.currentTime = 0;
                return;
            }
            let prevIndex = state.currentIndex - 1;
            if (prevIndex < 0) prevIndex = state.queue.length - 1;
            playTrackFromQueue(prevIndex);
        }

        function toggleShuffle() {
            state.shuffle = !state.shuffle;
            document.getElementById('shuffleBtn').style.opacity = state.shuffle ? '1' : '0.6';
        }

        function toggleRepeat() {
            state.repeat = !state.repeat;
            document.getElementById('repeatBtn').style.opacity = state.repeat ? '1' : '0.6';
        }

        function updatePlayIcons() {
            const path = state.isPlaying 
                ? "M6 19h4V5H6v14zm8-14v14h4V5h-4z" // Pause
                : "M8 5v14l11-7z"; // Play
            
            const miniBtn = document.querySelector('#miniPlayBtn svg path');
            const fullBtn = document.querySelector('#fullPlayBtn svg path');
            
            if(miniBtn) miniBtn.setAttribute('d', path);
            if(fullBtn) fullBtn.setAttribute('d', path);
        }

        function updatePlayerUI(track) {
            const artUrl = track.album?.cover 
                ? `https://resources.tidal.com/images/${track.album.cover.replace(/-/g, '/')}/640x640.jpg`
                : 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23333"/></svg>';

            // Mini Player
            document.getElementById('miniTitle').textContent = track.title;
            document.getElementById('miniArtist').textContent = track.artist?.name || "Unknown";
            document.getElementById('miniArt').src = artUrl;

            // Full Player
            document.getElementById('fullTitle').textContent = track.title;
            document.getElementById('fullArtist').textContent = track.artist?.name || "Unknown";
            document.getElementById('fullArt').src = artUrl;
            updateLikeIcon();
            updateQueueUI();


        }

        // --- 5. Timeline & Volume Events ---
        
        function updateProgress() {
            let player;
            
            if (universalPlayer.isInit) {
                player = universalPlayer.audioElement;
            } else if (state.isHiRes && dashPlayer.isInit) {
                player = dashPlayer.audioElement;
            } else {
                player = nativeAudio;
            }
            
            if (!player.duration) return;

            const percent = (player.currentTime / player.duration) * 100;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('currentTime').textContent = formatTime(player.currentTime);
            document.getElementById('totalTime').textContent = formatTime(player.duration);
            updateLyricsScroll(player.currentTime);
        }

        setInterval(updateProgress, 500);

        function formatTime(s) {
            if (isNaN(s)) return "0:00";
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec.toString().padStart(2, '0')}`;
        }

        function seek(e) {
            let player;
            
            if (universalPlayer.isInit) {
                player = universalPlayer.audioElement;
            } else if (state.isHiRes && dashPlayer.isInit) {
                player = dashPlayer.audioElement;
            } else {
                player = nativeAudio;
            }
            
            const bar = e.currentTarget;
            const percent = e.offsetX / bar.offsetWidth;
            player.currentTime = percent * player.duration;
            updateProgress();
        }

        function setVolume(val) {
            state.volume = val;
            universalPlayer.setVolume(val);
            dashPlayer.setVolume(val);
            nativeAudio.volume = val;
        }

        // --- 6. Search & Data Population ---
        
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('keypress', async (e) => {
            if(e.key === 'Enter') {
                const query = e.target.value;
                const res = await fetch(`${API_URL}/search/?s=${encodeURIComponent(query)}`);
                const data = await res.json();
                
                const container = document.getElementById('searchResults');
                container.innerHTML = `<h2 class="section-title">Results for "${query}"</h2><div class="grid"></div>`;
                const grid = container.querySelector('.grid');

                if(data.data && data.data.items) {
                    grid.innerHTML = data.data.items.slice(0, 10).map((track, i) => createCard(track, i, true)).join('');
                }
            }
        });

        function createCard(track, index = 0, isSearchResult = false) {
            const artUrl = track.album?.cover 
                ? `https://resources.tidal.com/images/${track.album.cover.replace(/-/g, '/')}/320x320.jpg`
                : '';
            
            // Serialize track object for onclick
            const trackStr = JSON.stringify(track).replace(/"/g, '&quot;').replace(/'/g, "&#39;");
            
            return `
                <div class="card animate-in" style="animation-delay: ${index * 50}ms" onclick='playTrack(${trackStr}, false, ${isSearchResult})'>
                    <div class="artwork">
                        <img src="${artUrl}" loading="lazy">
                    </div>
                    <div class="card-title">${track.title}</div>
                    <div class="card-subtitle">${track.artist?.name}</div>
                </div>
            `;
        }

        function addToHistory(track) {
            try {
                let history = JSON.parse(localStorage.getItem('listening_history') || '[]');
                history = history.filter(t => t.id !== track.id);
                history.unshift(track);
                if (history.length > 20) history.pop();
                localStorage.setItem('listening_history', JSON.stringify(history));
                loadRecommendations();
            } catch (e) { console.error(e); }
        }

        // Initial Dummy Data for "Listen Now"
        function loadRecommendations() {
            const history = JSON.parse(localStorage.getItem('listening_history') || '[]');
            const grid = document.getElementById('recommendations');
            grid.innerHTML = '';
            
            if (history.length === 0) {
                grid.innerHTML = '<p style="color:var(--text-secondary); grid-column:1/-1;">Recently played songs will appear here.</p>';
                return;
            }

            grid.innerHTML = history.map((track, i) => createCard(track, i)).join('');
        }

        // --- 7. Lyrics Implementation ---
        async function fetchLyrics(track) {
            const container = document.getElementById('lyricsContent');
            container.innerHTML = '<div class="spinner"></div>';
            state.lyrics = null;
            state.syncedLyrics = [];
            document.getElementById('translateBtn').classList.add('hidden');

            const title = encodeURIComponent(track.title);
            const artist = encodeURIComponent(track.artist?.name || '');
            
            if (!track.artist?.name) {
                container.innerHTML = '<p style="text-align:center; color:var(--text-secondary)">No lyrics found.</p>';
                return;
            }

            const album = encodeURIComponent(track.album?.title || '');
            const duration = track.duration || 0;

            const url = `https://lyricsplus.prjktla.workers.dev/v2/lyrics/get?title=${title}&artist=${artist}&album=${album}&duration=${duration}&source=apple%2Clyricsplus%2Cmusixmatch%2Cspotify%2Cmusixmatch-word`;
            
            try {
                const res = await fetch(url);
                const data = await res.json();
                
                if (data && data.lyrics) {
                    state.lyrics = data;
                    renderLyrics(data);
                } else {
                    container.innerHTML = '<p style="text-align:center; color:var(--text-secondary)">No lyrics found.</p>';
                }
            } catch (e) {
                container.innerHTML = '<p style="text-align:center; color:var(--text-secondary)">Could not load lyrics.</p>';
            }
        }

        function renderLyrics(data) {
            const container = document.getElementById('lyricsContent');
            container.innerHTML = '';
            
            let lines = [];

            // Handle JSON Array format (Apple Music / API style)
            if (Array.isArray(data.lyrics)) {
                lines = data.lyrics.map(line => ({
                    time: line.time / 1000, // Convert ms to seconds
                    text: line.text,
                    words: line.words ? line.words.map(w => ({
                        text: w.text,
                        time: w.time / 1000
                    })) : null
                }));
            } 
            // Handle LRC String format (Fallback)
            else if (typeof data.lyrics === 'string') {
                lines = parseLRC(data.lyrics);
            }

            state.syncedLyrics = lines;

            if (lines.length > 0) {
                lines.forEach((line, index) => {
                    const div = document.createElement('div');
                    div.className = 'lyrics-line';
                    div.dataset.time = line.time;
                    div.dataset.index = index;
                    
                    if (line.words && line.words.length > 0) {
                        div.innerHTML = line.words.map(w => 
                            `<span class="lyric-word" data-time="${w.time}">${w.text}</span>`
                        ).join(' ');
                    } else {
                        div.textContent = line.text;
                    }

                    div.onclick = () => {
                        const player = state.isHiRes ? dashPlayer : nativeAudio;
                        player.currentTime = line.time;
                    };
                    container.appendChild(div);
                });
            } else {
                container.innerHTML = `<div style="white-space: pre-wrap; font-size: 18px; line-height: 1.6;">${data.lyrics}</div>`;
                const text = typeof data.lyrics === 'string' ? data.lyrics : "Lyrics not available.";
                container.innerHTML = `<div style="white-space: pre-wrap; font-size: 18px; line-height: 1.6;">${text}</div>`;
            }

            // Check translation availability (mock logic as API response structure for translation varies)
            // If the API returns a translation field, we would enable the button.
            // For now, we just show the button if lyrics exist to demonstrate the UI requested.
            document.getElementById('translateBtn').classList.remove('hidden');
        }

        function parseLRC(lrc) {
            const regex = /^\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
            const lines = lrc.split('\n');
            const result = [];
            
            for (const line of lines) {
                const match = line.match(regex);
                if (match) {
                    const min = parseInt(match[1]);
                    const sec = parseInt(match[2]);
                    const ms = parseInt(match[3]);
                    const time = min * 60 + sec + (ms / 1000);
                    result.push({ time, text: match[4].trim() });
                }
            }
            return result;
        }

        function updateLyricsScroll(time) {
            if (!state.syncedLyrics.length || !document.getElementById('lyricsView').classList.contains('active')) return;

            const lines = state.syncedLyrics;
            let activeIndex = -1;

            for (let i = 0; i < lines.length; i++) {
                if (time >= lines[i].time) {
                    activeIndex = i;
                } else {
                    break;
                }
            }

            const divs = document.querySelectorAll('.lyrics-line');
            divs.forEach(d => d.classList.remove('active'));

            if (activeIndex !== -1 && divs[activeIndex]) {
                const activeLine = divs[activeIndex];
                activeLine.classList.add('active');
                
                // Handle Word Sync
                const words = activeLine.querySelectorAll('.lyric-word');
                if (words.length > 0) {
                    let activeWord = null;
                    words.forEach(w => {
                        w.classList.remove('active');
                        if (time >= parseFloat(w.dataset.time)) activeWord = w;
                    });
                    if (activeWord) activeWord.classList.add('active');
                }

                activeLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function togglePlayerView(view) {
            const art = document.getElementById('artContainer');
            const lyrics = document.getElementById('lyricsView');
            const queue = document.getElementById('queueView');

            // Reset all
            lyrics.classList.remove('active');
            queue.classList.remove('active');
            art.style.display = 'block';

            if (view === 'lyrics') {
                if (lyrics.style.display === 'block') {
                    lyrics.style.display = 'none'; // Toggle off
                } else {
                    art.style.display = 'none';
                    lyrics.classList.add('active');
                    lyrics.style.display = 'block';
                    queue.style.display = 'none';
                }
            } else if (view === 'queue') {
                if (queue.style.display === 'block') {
                    queue.style.display = 'none';
                } else {
                    art.style.display = 'none';
                    queue.classList.add('active');
                    queue.style.display = 'block';
                    lyrics.style.display = 'none';
                }
            }
        }

        async function toggleTranslation() {
            if (!state.lyrics || !state.lyrics.lyrics) {
                alert("No lyrics available to translate.");
                return;
            }

            // Get the lyrics text
            let lyricsText = '';
            if (Array.isArray(state.lyrics.lyrics)) {
                lyricsText = state.lyrics.lyrics.map(line => line.text).join('\n');
            } else if (typeof state.lyrics.lyrics === 'string') {
                lyricsText = state.lyrics.lyrics;
            } else {
                alert("Lyrics format not supported for translation.");
                return;
            }

            // Toggle translation state
            state.showTranslation = !state.showTranslation;

            if (state.showTranslation) {
                // Show loading
                const container = document.getElementById('lyricsContent');
                container.innerHTML = '<div class="spinner"></div>';

                try {
                    // Encode the text for URL
                    const encodedText = encodeURIComponent(lyricsText);

                    // Use Google Translate API (detect source language, translate to Italian)
                    const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=it&dt=t&q=${encodedText}`);
                    const data = await response.json();

                    // Parse the response - Google Translate returns [[[translated], [original]], ...]
                    let translatedText = '';
                    if (data && data[0]) {
                        translatedText = data[0].map(item => item[0]).join('');
                    }

                    // Update the lyrics display with translated text
                    container.innerHTML = '';
                    const translatedLines = translatedText.split('\n');
                    
                    // Try to map translated lines to original timestamps if counts match
                    const useSync = state.syncedLyrics && translatedLines.length === state.syncedLyrics.length;

                    translatedLines.forEach((line, index) => {
                        const div = document.createElement('div');
                        div.className = 'lyrics-line';
                        div.textContent = line;
                        if (useSync) div.dataset.time = state.syncedLyrics[index].time;
                        container.appendChild(div);
                    });

                } catch (error) {
                    console.error("Translation failed:", error);
                    alert("Translation failed. Please try again.");
                    state.showTranslation = false;
                    renderLyrics(state.lyrics); // Re-render original lyrics
                }
            } else {
                // Re-render original lyrics
                renderLyrics(state.lyrics);
            }
        }

        // --- 8. Queue & Library Features ---
        function updateQueueUI() {
            const container = document.getElementById('queueList');
            container.innerHTML = '';
            container.innerHTML = state.queue.map((track, i) => {
                const isPlaying = i === state.currentIndex;
                return `
                    <div class="list-item animate-in" style="animation-delay: ${i * 50}ms" onclick="playTrackFromQueue(${i})">
                        <div class="list-artwork">
                            <img src="${track.album?.cover ? `https://resources.tidal.com/images/${track.album.cover.replace(/-/g, '/')}/320x320.jpg` : ''}">
                        </div>
                        <div class="list-info" style="${isPlaying ? 'opacity:0.5' : ''}">
                            <div class="card-title" style="${isPlaying ? 'color:var(--accent)' : ''}">${track.title}</div>
                            <div class="card-subtitle">${track.artist?.name}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function playTrackFromQueue(index) {
            state.currentIndex = index;
            playTrack(state.queue[index], true);
        }

        function createPlaylist() {
            const name = prompt("Playlist Name:");
            if (name) {
                state.playlists.push({ name: name, songs: [] });
                localStorage.setItem('playlists', JSON.stringify(state.playlists));
                renderPlaylists();
            }
        }
        
        // --- CSV Import Helpers (Based on provided mechanism) ---
        function levenshtein(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;
            const matrix = [];
            for (let i = 0; i <= b.length; i++) { matrix[i] = [i]; }
            for (let j = 0; j <= a.length; j++) { matrix[0][j] = j; }
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function parseCSVLine(line) {
            const parts = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    parts.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            parts.push(current.trim());
            return parts;
        }

        function parseSpotifyCSV(text) {
            const lines = text.split('\n').filter(l => l.trim());
            let headerIndex = -1;
            const headers = {};
            
            // Detect Header Row
            for (let i = 0; i < Math.min(lines.length, 20); i++) {
                const row = parseCSVLine(lines[i]);
                if (row.includes('Track Name') && row.includes('Artist Name(s)')) {
                    headerIndex = i;
                    row.forEach((h, idx) => headers[h] = idx);
                    break;
                }
            }

            if (headerIndex === -1) return null;

            const results = [];
            for (let i = headerIndex + 1; i < lines.length; i++) {
                const row = parseCSVLine(lines[i]);
                if (row.length < 2) continue;
                
                results.push({
                    title: row[headers['Track Name']] || '',
                    artist: row[headers['Artist Name(s)']] || '',
                    album: row[headers['Album Name']] || ''
                });
            }
            return results;
        }

        let importState = { tracks: [], currentIndex: 0, foundTracks: [] };

        function handleCSVImport(input) {
            const file = input.files[0];
            if (!file) return;

            // Show Overlay
            let overlay = document.getElementById('importOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'importOverlay';
                overlay.innerHTML = `
                    <h2 style="margin-bottom:10px">Import Playlist</h2>
                    <div id="importLog"></div>
                    <button class="btn-text" id="nextBtn" style="margin-top:20px; display:none;" onclick="processNextTrack()">Next</button>
                    <button class="btn-text" style="margin-top:20px" onclick="this.parentElement.remove()">Close</button>
                `;
                document.body.appendChild(overlay);
            } else {
                document.body.appendChild(overlay);
            }

            const log = document.getElementById('importLog');
            log.innerHTML = '';
            const logMsg = (msg) => {
                const div = document.createElement('div');
                div.textContent = `> ${msg}`;
                div.style.marginBottom = '4px';
                div.style.borderBottom = '1px solid #333';
                log.appendChild(div);
                log.scrollTop = log.scrollHeight;
            };

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;

                // 1. Parse CSV using robust logic
                const parsedRows = parseSpotifyCSV(text);

                if (!parsedRows || parsedRows.length === 0) {
                    logMsg(" Error: Could not find headers 'Track Name' & 'Artist Name(s)'.");
                    alert("Invalid CSV format. Please use a Spotify export.");
                    input.value = '';
                    return;
                }

                importState.tracks = parsedRows;
                importState.currentIndex = 0;
                importState.foundTracks = [];

                logMsg(`File parsed. ${parsedRows.length} tracks found.`);
                logMsg("Click 'Next' to start adding tracks one by one.");

                // Show track list
                const trackList = parsedRows.map((row, i) => `<div id="track-${i}">${i + 1}. ${row.title} - ${row.artist}</div>`).join('');
                log.innerHTML += `<div style="margin-top:20px;">${trackList}</div>`;

                document.getElementById('nextBtn').style.display = 'block';
            };
            reader.readAsText(file);
        }

        async function processNextTrack() {
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.disabled = true;
            nextBtn.textContent = 'Processing...';

            for (let i = importState.currentIndex; i < importState.tracks.length; i++) {
                const row = importState.tracks[i];
                const log = document.getElementById('importLog');
                const logMsg = (msg) => {
                    const div = document.createElement('div');
                    div.textContent = `> ${msg}`;
                    div.style.marginBottom = '4px';
                    div.style.borderBottom = '1px solid #333';
                    log.appendChild(div);
                    log.scrollTop = log.scrollHeight;
                };

                const trackDiv = document.getElementById(`track-${i}`);
                trackDiv.style.color = 'yellow'; // Processing

                // Search Query: Title + Artist only (ignore Album)
                let query = `${row.title} ${row.artist}`;

                try {
                    logMsg(`Searching: "${query}"...`);
                    const res = await fetch(`${API_URL}/search/?s=${encodeURIComponent(query)}`);
                    const data = await res.json();

                    if (data.data && data.data.items && data.data.items.length > 0) {
                        // Fuzzy Match Filter
                        const bestMatch = data.data.items.find(track => {
                            const tTitle = track.title.toLowerCase();
                            const tArtist = (track.artist?.name || '').toLowerCase();
                            const expTitle = row.title.toLowerCase();
                            const expArtist = row.artist.toLowerCase();

                            const titleMatch = tTitle.includes(expTitle) || expTitle.includes(tTitle) || levenshtein(tTitle, expTitle) <= 2;
                            const artistMatch = tArtist.includes(expArtist) || expArtist.includes(tArtist) || levenshtein(tArtist, expArtist) <= 2;

                            return titleMatch && artistMatch;
                        });

                        if (bestMatch) {
                            importState.foundTracks.push(bestMatch);
                            trackDiv.style.color = 'green'; // Success
                            logMsg(` Added: ${bestMatch.title}`);
                        } else {
                            trackDiv.style.color = 'red'; // No match
                            logMsg(` No match for: ${row.title}`);
                        }
                    } else {
                        trackDiv.style.color = 'red';
                        logMsg(` No results for: ${row.title}`);
                    }
                } catch (err) {
                    console.error("Import search error", err);
                    trackDiv.style.color = 'red';
                    logMsg(` Error: ${err.message}`);
                }

                importState.currentIndex = i + 1;

                // Small delay to prevent overwhelming the UI
                await new Promise(r => setTimeout(r, 100));
            }

            // All done
            const name = 'Imported Playlist'; // Or use file name
            state.playlists.push({ name: name, songs: importState.foundTracks });
            localStorage.setItem('playlists', JSON.stringify(state.playlists));
            renderPlaylists();
            alert(`Import Complete. ${importState.foundTracks.length} songs added.`);
            document.getElementById('importOverlay').remove();
        }

        function renderPlaylists() {
            const container = document.getElementById('playlistsList');
            container.innerHTML = '';
            container.innerHTML = state.playlists.map((pl, index) => {
                return `
                    <div class="list-item animate-in" style="animation-delay: ${index * 50}ms" onclick="openPlaylist(${index})">
                        <div class="list-artwork" style="background:#333; display:flex; align-items:center; justify-content:center;">
                            <svg class="icon" style="color:#666" viewBox="0 0 24 24"><path d="M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7z"/></svg>
                        </div>
                        <div class="list-info">
                            <div class="card-title">${pl.name}</div>
                            <div class="card-subtitle">${pl.songs.length} songs</div>
                        </div>
                        <button class="delete-btn" onclick="deletePlaylist(event, ${index})">
                            <svg class="icon" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                        </button>
                    </div>
                `;
            }).join('');
        }

        function deletePlaylist(event, index) {
            event.stopPropagation();
            if(confirm('Delete this playlist?')) {
                state.playlists.splice(index, 1);
                localStorage.setItem('playlists', JSON.stringify(state.playlists));
                renderPlaylists();
            }
        }

        // --- 9. Collection & Like Logic ---

        function toggleLike() {
            const track = state.queue[state.currentIndex];
            if (!track) return;

            const index = state.likedSongs.findIndex(t => t.id === track.id);
            if (index > -1) {
                state.likedSongs.splice(index, 1);
            } else {
                state.likedSongs.unshift(track);
            }
            localStorage.setItem('likedSongs', JSON.stringify(state.likedSongs));
            updateLikeIcon();
        }

        function updateLikeIcon() {
            const track = state.queue[state.currentIndex];
            const btn = document.querySelector('#likeBtn svg');
            const path = btn.querySelector('path');
            
            if (track && state.likedSongs.some(t => t.id === track.id)) {
                btn.style.color = 'var(--accent)';
                path.setAttribute('d', "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z");
            } else {
                btn.style.color = 'var(--text-secondary)';
                path.setAttribute('d', "M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z");
            }
        }

        function openLikedSongs() {
            openCollection('Liked Songs', state.likedSongs);
        }

        function openPlaylist(index) {
            const pl = state.playlists[index];
            openPlaylistPage(pl.name, pl.songs, index);
        }

        function openPlaylistPage(title, songs, playlistIndex) {
            // Show playlist page instead of collection view
            document.getElementById('tab-library').classList.add('hidden');
            document.getElementById('tab-collection').classList.add('hidden');
            document.getElementById('tab-playlist-page').classList.remove('hidden');
            
            document.getElementById('playlistPageTitle').textContent = title;
            document.getElementById('playlistPageCount').textContent = `${songs.length} songs`;
            
            // Get first song artwork for playlist cover
            const coverArt = songs.length > 0 && songs[0].album?.cover 
                ? `https://resources.tidal.com/images/${songs[0].album.cover.replace(/-/g, '/')}/640x640.jpg`
                : 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23333"/><circle cx="50" cy="50" r="30" fill="%23666"/></svg>';
            
            document.getElementById('playlistPageCover').src = coverArt;
            
            // Setup play button
            const playBtn = document.getElementById('playlistPlayBtn');
            playBtn.onclick = () => {
                if (songs.length > 0) {
                    // Load all songs in queue and start playing
                    state.queue = [...songs];
                    state.currentIndex = 0;
                    state.currentPlaylistIndex = playlistIndex;
                    playTrack(songs[0], true, false, playlistIndex);
                    openFullPlayer();
                }
            };
            
            // Render songs list
            const container = document.getElementById('playlistSongsList');
            container.innerHTML = '';
            
            if (songs.length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary); text-align:center; margin-top:50px;">No songs in this playlist.</p>';
                return;
            }

            container.innerHTML = songs.map((track, i) => {
                const trackStr = JSON.stringify(track).replace(/"/g, '&quot;').replace(/'/g, "&#39;");
                const artUrl = track.album?.cover ? `https://resources.tidal.com/images/${track.album.cover.replace(/-/g, '/')}/320x320.jpg` : '';
                
                return `
                    <div class="list-item animate-in" style="animation-delay: ${i * 50}ms" onclick='handlePlaylistSongClick(${trackStr}, ${playlistIndex})'>
                        <div class="list-artwork"><img src="${artUrl}"></div>
                        <div class="list-info"><div class="card-title">${track.title}</div><div class="card-subtitle">${track.artist?.name}</div></div>
                    </div>`;
            }).join('');
        }

        function handlePlaylistSongClick(track, playlistIndex) {
            // When clicking a song in playlist, load whole playlist as queue starting from that song
            const pl = state.playlists[playlistIndex];
            const songIndex = pl.songs.findIndex(t => t.id === track.id);
            
            state.queue = [...pl.songs];
            state.currentIndex = songIndex >= 0 ? songIndex : 0;
            state.currentPlaylistIndex = playlistIndex;
            playTrack(state.queue[state.currentIndex], true, false, playlistIndex);
        }

        function closePlaylistPage() {
            document.getElementById('tab-playlist-page').classList.add('hidden');
            document.getElementById('tab-library').classList.remove('hidden');
        }

        function openCollection(title, songs) {
            document.getElementById('tab-library').classList.add('hidden');
            document.getElementById('tab-collection').classList.remove('hidden');
            document.getElementById('collectionTitle').textContent = title;
            
            const container = document.getElementById('collectionList');
            container.innerHTML = '';
            
            if (songs.length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary); text-align:center; margin-top:50px;">No songs yet.</p>';
                return;
            }

            container.innerHTML = songs.map((track, i) => {
                // We use createCard style but as list item
                const trackStr = JSON.stringify(track).replace(/"/g, '&quot;').replace(/'/g, "&#39;");
                const artUrl = track.album?.cover ? `https://resources.tidal.com/images/${track.album.cover.replace(/-/g, '/')}/320x320.jpg` : '';
                
                return `
                    <div class="list-item animate-in" style="animation-delay: ${i * 50}ms" onclick='playTrack(${trackStr})'>
                        <div class="list-artwork"><img src="${artUrl}"></div>
                        <div class="list-info"><div class="card-title">${track.title}</div><div class="card-subtitle">${track.artist?.name}</div></div>
                    </div>`;
            }).join('');
        }

        function closeCollection() {
            document.getElementById('tab-collection').classList.add('hidden');
            document.getElementById('tab-library').classList.remove('hidden');
        }

        loadRecommendations();
        renderPlaylists();

        // --- PWA Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('SW registered:', reg))
                    .catch(err => console.log('SW registration failed:', err));
            });
        }

        // --- Request Persistent Storage ---
        if (navigator.storage && navigator.storage.persist) {
            navigator.storage.persist().then(granted => {
                console.log("Persistent storage granted: " + granted);
            });
        }

        // --- Update Banner ---
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'UPDATE_AVAILABLE') {
                    showUpdateBanner();
                }
            });
        }

        function showUpdateBanner() {
            // Remove existing banner if present
            const existingBanner = document.getElementById('updateBanner');
            if (existingBanner) existingBanner.remove();

            const banner = document.createElement('div');
            banner.id = 'updateBanner';
            banner.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: var(--accent);
                color: white;
                padding: 12px 20px;
                text-align: center;
                font-size: 14px;
                font-weight: 500;
                z-index: 1000;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                animation: slideDown 0.3s ease;
            `;
            banner.innerHTML = `
                <span>New features available! Refresh to update.</span>
                <button onclick="location.reload()" style="
                    margin-left: 15px;
                    background: rgba(255,255,255,0.2);
                    border: none;
                    color: white;
                    padding: 4px 12px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 12px;
                ">Refresh</button>
                <button onclick="this.parentElement.remove()" style="
                    margin-left: 10px;
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                    font-size: 16px;
                    opacity: 0.8;
                "></button>
            `;

            document.body.appendChild(banner);

            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideDown {
                    from { transform: translateY(-100%); }
                    to { transform: translateY(0); }
                }
            `;
            document.head.appendChild(style);
        }
    </script>
</body>
</html>